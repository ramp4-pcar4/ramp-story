import{gY as E,cD as U,cI as u,hg as l,cC as p,dF as st,cH as P,cE as at,hk as I,cL as rt,cK as ct,cJ as m,cN as O,eH as V,ed as ut,eD as gt,eo as h,ih as bt,ii as x,cO as R,ie as H,cB as M,Q as ft}from"./story-DE9AooAy.js";import{B as k,p as lt}from"./sphere-_Zcui0FU-CoSuXPKk.js";import{t as z}from"./mat4f64-Dn1WEGBx-C99QVUMW.js";import{u as pt,p as L,h as dt}from"./lineSegment-CMEPBlyR-BAB-eRfw.js";import{B as w,b as ht,$ as mt,T as A,f as a,k as It,M as Nt,S as Pt,m as Mt,g as G,D as Tt,P as T,N as S,h as St}from"./plane-B2J4G_40-YEDqrpJy.js";const C=()=>ft.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class vt{constructor(){this.plane=w(),this.origin=M(),this.basis1=M(),this.basis2=M()}}const wt=vt;function N(t=ot){return{plane:w(t.plane),origin:U(t.origin),basis1:U(t.basis1),basis2:U(t.basis2)}}function Bt(t,i,n){const e=Rt.get();return e.origin=t,e.basis1=i,e.basis2=n,e.plane=ht(0,0,0,0),_(e),e}function B(t,i=N()){return J(t.origin,t.basis1,t.basis2,i)}function _t(t,i){u(i.origin,t.origin),u(i.basis1,t.basis1),u(i.basis2,t.basis2),mt(i.plane,t.plane)}function J(t,i,n,e=N()){return u(e.origin,t),u(e.basis1,i),u(e.basis2,n),_(e),jt(e,"fromValues()"),e}function _(t){A(t.basis2,t.basis1,t.origin,t.plane)}function X(t,i,n){t!==n&&B(t,n);const e=l(a.get(),f(t),i);return p(n.origin,n.origin,e),n.plane[3]-=i,n}function yt(t,i,n){return K(i,n),X(n,Y(t,t.origin),n),n}function Et(t,i){const n=t.basis1[0],e=t.basis2[1],[o,s]=t.origin;return st(o-n,s-e,o+n,s+e,i)}function K(t,i=N()){const n=(t[2]-t[0])/2,e=(t[3]-t[1])/2;return P(i.origin,t[0]+n,t[1]+e,0),P(i.basis1,n,0,0),P(i.basis2,0,e,0),It(0,0,1,0,i.plane),i}function D(t,i,n){return!!Nt(t.plane,i,n)&&it(t,n)}function Ut(t,i,n){if(D(t,i,n))return n;const e=W(t,i,a.get());return p(n,i.origin,l(a.get(),i.direction,at(i.origin,e)/I(i.direction))),n}function W(t,i,n){const e=v.get();et(t,i,e,v.get());let o=Number.POSITIVE_INFINITY;for(const s of q){const r=j(t,s,y.get()),g=a.get();if(Pt(e,r,g)){const c=rt(a.get(),i.origin,g),b=Math.abs(ct(m(i.direction,c)));b<o&&(o=b,u(n,g))}}return o===Number.POSITIVE_INFINITY?Z(t,i,n):n}function Vt(t,i){return(i-t)/i}function Z(t,i,n){if(D(t,i,n))return n;const e=v.get(),o=v.get();et(t,i,e,o);let s=Number.POSITIVE_INFINITY;for(const r of q){const g=j(t,r,y.get()),c=a.get();if(Mt(e,g,c)){const b=lt(i,c);if(!G(o,c))continue;b<s&&(s=b,u(n,c))}}return F(t,i.origin)<s&&tt(t,i.origin,n),n}function tt(t,i,n){const e=Tt(t.plane,i,a.get()),o=L(Q(t,t.basis1),e,-1,1,a.get()),s=L(Q(t,t.basis2),e,-1,1,a.get());return O(n,p(a.get(),o,s),t.origin),n}function nt(t,i,n){const{origin:e,basis1:o,basis2:s}=t,r=O(a.get(),i,e),g=T(o,r),c=T(s,r),b=T(f(t),r);return P(n,g,c,b)}function F(t,i){const n=nt(t,i,a.get()),{basis1:e,basis2:o}=t,s=I(e),r=I(o),g=Math.max(Math.abs(n[0])-s,0),c=Math.max(Math.abs(n[1])-r,0),b=n[2];return g*g+c*c+b*b}function xt(t,i){return Math.sqrt(F(t,i))}function Ct(t,i){let n=Number.NEGATIVE_INFINITY;for(const e of q){const o=j(t,e,y.get()),s=dt(o,i);s>n&&(n=s)}return Math.sqrt(n)}function $t(t,i){return G(t.plane,i)&&it(t,i)}function At(t,i,n,e){return Yt(t,n,e)}function Y(t,i){const n=-t.plane[3];return T(f(t),i)-n}function Ot(t,i,n,e){const o=Y(t,i),s=l(qt,f(t),n-o);return p(e,i,s),e}function kt(t,i){return V(t.basis1,i.basis1)&&V(t.basis2,i.basis2)&&V(t.origin,i.origin)}function Dt(t,i,n){return t!==n&&B(t,n),ut(d,i),gt(d,d),h(n.basis1,t.basis1,d),h(n.basis2,t.basis2,d),h(S(n.plane),S(t.plane),d),h(n.origin,t.origin,i),St(n.plane,n.plane,n.origin),n}function Ft(t,i,n,e){return t!==e&&B(t,e),bt($,i,n),h(e.basis1,t.basis1,$),h(e.basis2,t.basis2,$),_(e),e}function f(t){return S(t.plane)}function Yt(t,i,n){switch(i){case x.X:u(n,t.basis1),R(n,n);break;case x.Y:u(n,t.basis2),R(n,n);break;case x.Z:u(n,f(t))}return n}function it(t,i){const n=O(a.get(),i,t.origin),e=H(t.basis1),o=H(t.basis2),s=m(t.basis1,n),r=m(t.basis2,n);return-s-e<0&&s-e<0&&-r-o<0&&r-o<0}function Q(t,i){const n=y.get();return u(n.origin,t.origin),u(n.vector,i),n}function j(t,i,n){const{basis1:e,basis2:o,origin:s}=t,r=l(a.get(),e,i.origin[0]),g=l(a.get(),o,i.origin[1]);p(n.origin,r,g),p(n.origin,n.origin,s);const c=l(a.get(),e,i.direction[0]),b=l(a.get(),o,i.direction[1]);return l(n.vector,p(c,c,b),2),n}function jt(t,i){Math.abs(m(t.basis1,t.basis2)/(I(t.basis1)*I(t.basis2)))>1e-6&&C().warn(i,"Provided basis vectors are not perpendicular"),Math.abs(m(t.basis1,f(t)))>1e-6&&C().warn(i,"Basis vectors and plane normal are not perpendicular"),Math.abs(-m(f(t),t.origin)-t.plane[3])>1e-6&&C().warn(i,"Plane offset is not consistent with plane origin")}function et(t,i,n,e){const o=f(t);A(o,i.direction,i.origin,n),A(S(n),o,i.origin,e)}const ot={plane:w(),origin:E(0,0,0),basis1:E(1,0,0),basis2:E(0,1,0)},v=new k(w),y=new k(pt),qt=M(),Rt=new k(()=>N()),q=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],d=z(),$=z(),Jt=Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:wt,altitudeAt:Y,axisAt:At,cameraFrustumCoverage:Vt,closestPoint:Z,closestPointOnSilhouette:W,copy:B,copyWithoutVerify:_t,create:N,distance:xt,distance2:F,distanceToSilhouette:Ct,elevate:X,equals:kt,extrusionContainsPoint:$t,fromAABoundingRect:K,fromValues:J,getExtent:Et,intersectRay:D,intersectRayClosestSilhouette:Ut,normal:f,projectPoint:tt,projectPointLocal:nt,rotate:Ft,setAltitudeAt:Ot,setExtent:yt,transform:Dt,up:ot,updateUnboundedPlane:_,wrap:Bt},Symbol.toStringTag,{value:"Module"}));export{Jt as H,B as M,_ as N,N as h,J as j};
