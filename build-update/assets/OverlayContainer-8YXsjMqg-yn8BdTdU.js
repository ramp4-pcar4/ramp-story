import{c as i,fd as U,lJ as H,lL as V,nv as J,nH as X,mQ as Y,lU as Z,e$ as tt,h8 as et,lV as st,d7 as it,oC as ot,jh as rt,jk as T,bR as nt,e4 as L,jg as at,mx as j}from"./story-u82SUoyt.js";import{t as dt}from"./vec3f32-BS0cezmI-B_madU1n.js";import{N as pt}from"./WGLContainer-whJgsi2t-uiIX2w2R.js";import{T as lt,s as B,P as ht}from"./FeatureCommandQueue-F8dH-mVd-Dn6ySB5Z.js";import{t as F,S as d,aw as k,ax as ct,ar as y,C as G,L as ut,N as z,a_ as ft,ay as vt,aC as xt,a4 as mt,A as yt,a7 as gt,bd as wt,b9 as _t,D as Mt}from"./UpdateTracking2D-swFQJIjy-DIMKE4HS.js";class C extends ct{}i([F(0,y)],C.prototype,"pos",void 0),i([F(1,y)],C.prototype,"uv",void 0);class St extends wt{}class W extends G{}i([d(ut)],W.prototype,"dvs",void 0);class v extends G{}i([d(y)],v.prototype,"perspective",void 0),i([d(y)],v.prototype,"texSize",void 0),i([d(z)],v.prototype,"wrapAroundShift",void 0),i([d(z)],v.prototype,"opacity",void 0),i([d(ft)],v.prototype,"texture",void 0);class m extends vt{vertex(t){const s=t.uv.divide(this.config.texSize),e=new z(1).add(xt(s,this.config.perspective)),a=new mt(t.pos.add(new y(this.config.wrapAroundShift,0)),1),o=this.transform.dvs.multiply(a);return{uv:s,glPosition:new yt(o.xy.multiply(e),0,e)}}fragment(t){const s=gt(this.config.texture,t.uv).multiply(this.config.opacity),e=new _t;return e.glFragColor=s,e}}i([d(W)],m.prototype,"transform",void 0),i([d(v)],m.prototype,"config",void 0),i([U(0,k(C))],m.prototype,"vertex",null),i([U(0,k(St))],m.prototype,"fragment",null);let bt=class extends lt{constructor(){super(...arguments),this.type=Mt.Overlay,this._mesh=null,this.shaders={overlay:new m}}render(n,t){const{context:s,painter:e}=n,a=this._getMesh(n,t);e.setPipelineState(B);const{isWrapAround:o,wrapAroundShift:p}=t.config,l={...t.config,wrapAroundShift:0},u={shader:this.shaders.overlay,uniforms:{transform:t.transform,config:l},defines:null,optionalAttributes:null,useComputeBuffer:!1};e.setPipelineState({...B,stencil:{write:!1,test:{compare:rt.EQUAL,op:{fail:T.KEEP,zFail:T.KEEP,zPass:T.REPLACE},ref:0,mask:255}}}),e.submitDrawMeshUntyped(s,u,a),o&&(l.wrapAroundShift=p,e.submitDrawMeshUntyped(s,u,a))}shutdown(){nt(this._mesh)}_getMesh(n,t){const{context:s}=n;if(this._mesh){const e=this._mesh.vertexBuffers.get("positions");if(!e)throw new Error("Buffer not found");e.setData(t.position)}else{const e=t.index!=null?t.index.length:t.position.length/2;this._mesh=new ht(s,{vertex:{positions:t.position,uvs:t.tex},index:t.index!=null?{index:t.index}:void 0,groups:[{attributes:[{name:"pos",count:2,type:L.FLOAT,location:0,vertex:"positions",stride:8,offset:0},{name:"tex",count:2,type:L.UNSIGNED_SHORT,location:1,vertex:"uvs",stride:4,offset:0}],index:t.index!=null?"index":void 0,primitive:at.TRIANGLE_STRIP}],parts:[{group:0,start:0,count:e}]})}return this._mesh}};class zt extends pt{constructor(){super(...arguments),this._viewStateId=-1,this._dvsMat3=H(),this._overlayTechnique=new bt}get dvsMat3(){return this._dvsMat3}beforeRender(t){this._updateMatrices(t),this._updateOverlays(t,this.children);for(const s of this.children)s.beforeRender(t)}doRender(t){if(t.drawPhase!==V.MAP||!this.visible)return;super.doRender(t);const s=this._overlayTechnique;for(const e of this.children)e.draw(t,s)}onDetach(){this._overlayTechnique.shutdown()}_updateMatrices(t){const{state:s}=t,{id:e,size:a,pixelRatio:o,resolution:p,rotation:l,viewpoint:u,displayMat3:M}=s;if(this._viewStateId===e)return;const g=j(l),h=o*a[0],f=o*a[1];this._localOrigin=u.targetGeometry.clone();const{x,y:S}=this._localOrigin,w=J(x,s.spatialReference);this._localOrigin.x=w,this._localOrigin.y=S;const b=p*h,A=p*f,r=X(this._dvsMat3);Y(r,r,M),Z(r,r,tt(h/2,f/2)),et(r,r,dt(h/b,-f/A,1)),st(r,r,-g),this._viewStateId=e}_updateOverlays(t,s){const{state:e}=t,{rotation:a,spatialReference:o,worldScreenWidth:p,size:l,viewpoint:u}=e,M=this._localOrigin;let g,h=0;const f=it(o);if(f&&o.isWrappable){const x=l[0],S=l[1],w=j(a),b=Math.abs(Math.cos(w)),A=Math.abs(Math.sin(w)),r=Math.round(x*b+S*A),[D,O]=f.valid,c=ot(o),{x:N,y:$}=u.targetGeometry,q=[N,$],P=[0,0];e.toScreen(P,q);const _=[0,0];let R;R=r>p?.5*p:.5*r;const I=Math.floor((N+.5*c)/c),K=D+I*c,Q=O+I*c,E=[P[0]+R,0];e.toMap(_,E),_[0]>Q&&(h=c),E[0]=P[0]-R,e.toMap(_,E),_[0]<K&&(h=-c),g={worldWidth:c,xBounds:[D,O]}}for(const x of s)x.updateDrawCoords(M,h,o,g)}}export{zt as A};
