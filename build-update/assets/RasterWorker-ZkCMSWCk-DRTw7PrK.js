import{c as f,cm as u,j as p,cn as i,co as S,cp as d,cq as y,aa as n,cr as x,a3 as h,cs as O,ct as J,cu as N,cv as v,cw as B,cx as P,cy as g,cz as k,cA as w}from"./story-u82SUoyt.js";import{h as z,q as D,x as b,v as T}from"./PolynomialTransform-C_RaF2be-BWO_bhcW.js";import{V as j,L as A,J as G}from"./rasterProjectionHelper-CgVEist9-DpNrcr56.js";import"./main-CmCzAIzx.js";var c;let l=c=class extends D{constructor(){super(...arguments),this.type="identity"}clone(){return new c}};f([u({IdentityXform:"identity"})],l.prototype,"type",void 0),l=c=f([p("esri.layers.support.rasterTransforms.IdentityTransform")],l);const E=l,F={GCSShiftXform:b,IdentityXform:E,PolynomialXform:T};function I(a){if(!a?.type)return null;const r=F[a?.type];if(r){const t=new r;return t.read(a),t}return null}class C{convertVectorFieldData(r){const t=i.fromJSON(r.pixelBlock),s=S(t,r.type);return Promise.resolve(s!=null?s.toJSON():null)}computeStatisticsHistograms(r){const t=i.fromJSON(r.pixelBlock),s=d(t);return Promise.resolve(s)}async decode(r){const t=await y(r.data,r.options);return t&&t.toJSON()}symbolize(r){r.pixelBlock=i.fromJSON(r.pixelBlock),r.extent=r.extent?n.fromJSON(r.extent):null;const t=this.symbolizer.symbolize(r);return Promise.resolve(t!=null?t.toJSON():null)}async updateSymbolizer(r){this.symbolizer=x.fromJSON(r.symbolizerJSON),r.histograms&&this.symbolizer?.rendererJSON.type==="rasterStretch"&&(this.symbolizer.rendererJSON.histograms=r.histograms)}async updateRasterFunction(r){this.rasterFunction=z(r.rasterFunctionJSON)}async process(r){const t=this.rasterFunction.process({extent:n.fromJSON(r.extent),primaryPixelBlocks:r.primaryPixelBlocks.map(s=>s!=null?i.fromJSON(s):null),primaryPixelSizes:r.primaryPixelSizes?.map(s=>s!=null?h.fromJSON(s):null),primaryRasterIds:r.primaryRasterIds});return t!=null?t.toJSON():null}stretch(r){const t=this.symbolizer.simpleStretch(i.fromJSON(r.srcPixelBlock),r.stretchParams);return Promise.resolve(t?.toJSON())}estimateStatisticsHistograms(r){const t=O(i.fromJSON(r.srcPixelBlock));return Promise.resolve(t)}split(r){const t=J(i.fromJSON(r.srcPixelBlock),r.tileSize,r.maximumPyramidLevel??0,r.useBilinear===!1);return t&&t.forEach((s,e)=>{t.set(e,s?.toJSON())}),Promise.resolve(t)}clipTile(r){const t=i.fromJSON(r.pixelBlock),s=N({...r,pixelBlock:t});return Promise.resolve(s?.toJSON())}async mosaicAndTransform(r){const t=r.srcPixelBlocks.map(m=>m?new i(m):null),s=v(t,r.srcMosaicSize,{blockWidths:r.blockWidths,alignmentInfo:r.alignmentInfo,clipOffset:r.clipOffset,clipSize:r.clipSize});let e,o=s;return r.coefs&&(o=B(s,r.destDimension,r.coefs,r.sampleSpacing,r.interpolation)),r.projectDirections&&r.gcsGrid&&(e=P(r.destDimension,r.gcsGrid),o=g(o,r.isUV?"vector-uv":"vector-magdir",e)),{pixelBlock:o?.toJSON(),localNorthDirections:e}}async createFlowMesh(r,t){const s={data:new Float32Array(r.flowData.buffer),mask:new Uint8Array(r.flowData.maskBuffer),width:r.flowData.width,height:r.flowData.height},{vertexData:e,indexData:o}=await k(r.meshType,r.simulationSettings,s,t.signal);return{result:{vertexBuffer:e.buffer,indexBuffer:o.buffer},transferList:[e.buffer,o.buffer]}}async getProjectionOffsetGrid(r){const t=n.fromJSON(r.projectedExtent),s=n.fromJSON(r.srcBufferExtent);let e=null;r.datumTransformationSteps&&(e=new w({steps:r.datumTransformationSteps})),(r.includeGCSGrid||j(t.spatialReference,s.spatialReference,e))&&await A();const o=r.rasterTransform?I(r.rasterTransform):null;return G({...r,projectedExtent:t,srcBufferExtent:s,datumTransformation:e,rasterTransform:o})}}export{C as default};
