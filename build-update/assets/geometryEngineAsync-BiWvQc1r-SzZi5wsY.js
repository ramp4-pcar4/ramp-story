import{a3 as l,a1 as w,P as h}from"./story-u82SUoyt.js";import"./main-CmCzAIzx.js";function r(e){return Array.isArray(e)?e[0]?.spatialReference:e?.spatialReference}function p(e){return e&&(Array.isArray(e)?e.map(p):e.toJSON?e.toJSON():e)}function c(e){return Array.isArray(e)?e.map(t=>w(t)):w(e)}function S(e,t){let n;return Array.isArray(e)?n=e:(n=[],n.push(e),t!=null&&n.push(t)),n}let f;async function d(){return f||(f=h("geometryEngineWorker",{strategy:"distributed"})),f}async function a(e,t){return(await d()).invoke("executeGEOperation",{operation:e,parameters:p(t)})}async function m(e,t){const n=await d();return Promise.all(n.broadcast("executeGEOperation",{operation:e,parameters:p(t)}))}function A(e){return a("extendedSpatialReferenceInfo",[e])}async function O(e,t){return c(await a("clip",[r(e),e,t]))}async function J(e,t){return c(await a("cut",[r(e),e,t]))}function D(e,t){return a("contains",[r(e),e,t])}function N(e,t){return a("crosses",[r(e),e,t])}function L(e,t,n){return a("distance",[r(e),e,t,n])}function T(e,t){return a("equals",[r(e),e,t])}function V(e,t){return a("intersects",[r(e),e,t])}function v(e,t){return a("touches",[r(e),e,t])}function E(e,t){return a("within",[r(e),e,t])}function b(e,t){return a("disjoint",[r(e),e,t])}function z(e,t){return a("overlaps",[r(e),e,t])}function H(e,t,n){return a("relate",[r(e),e,t,n])}function P(e){return a("isSimple",[r(e),e])}async function G(e){return c(await a("simplify",[r(e),e]))}async function I(e,t=!1){return c(await a("convexHull",[r(e),e,t]))}async function j(e,t){return c(await a("difference",[r(e),e,t]))}async function k(e,t){return c(await a("symmetricDifference",[r(e),e,t]))}async function q(e,t){return c(await a("intersect",[r(e),e,t]))}async function B(e,t=null){const n=S(e,t);return c(await a("union",[r(n),n]))}async function C(e,t,n,i,s,u){return c(await a("offset",[r(e),e,t,n,i,s,u]))}async function W(e,t,n,i=!1){const s=[r(e),e,t,n,i];return c(await a("buffer",s))}async function F(e,t,n,i,s,u){const g=[r(e),e,t,n,i,s,u];return c(await a("geodesicBuffer",g))}async function K(e,t,n=!0){const i=await a("nearestCoordinate",[r(e),e,t,n]);return{...i,coordinate:l.fromJSON(i.coordinate)}}async function M(e,t){const n=await a("nearestVertex",[r(e),e,t]);return{...n,coordinate:l.fromJSON(n.coordinate)}}async function Q(e,t,n,i){return(await a("nearestVertices",[r(e),e,t,n,i])).map(s=>({...s,coordinate:l.fromJSON(s.coordinate)}))}function y(e){return"xmin"in e?e.center:"x"in e?e:e.extent?.center}async function U(e,t,n){if(e==null)throw new o;const i=e.spatialReference;if((n=n??y(e))==null)throw new o;const s=e.constructor.fromJSON(await a("rotate",[i,e,t,n]));return s.spatialReference=i,s}async function X(e,t){if(e==null)throw new o;const n=e.spatialReference;if((t=t??y(e))==null)throw new o;const i=e.constructor.fromJSON(await a("flipHorizontal",[n,e,t]));return i.spatialReference=n,i}async function Y(e,t){if(e==null)throw new o;const n=e.spatialReference;if((t=t??y(e))==null)throw new o;const i=e.constructor.fromJSON(await a("flipVertical",[n,e,t]));return i.spatialReference=n,i}async function Z(e,t,n,i){return c(await a("generalize",[r(e),e,t,n,i]))}async function _(e,t,n){return c(await a("densify",[r(e),e,t,n]))}async function $(e,t,n,i=0){return c(await a("geodesicDensify",[r(e),e,t,n,i]))}function ee(e,t){return a("planarArea",[r(e),e,t])}function te(e,t){return a("planarLength",[r(e),e,t])}function ne(e,t,n){return a("geodesicArea",[r(e),e,t,n])}function ae(e,t,n){return a("geodesicLength",[r(e),e,t,n])}async function re(e,t){return c(await a("intersectLinesToPoints",[r(e),e,t]))}async function ie(e,t){await m("changeDefaultSpatialReferenceTolerance",[e,t])}async function ce(e){await m("clearDefaultSpatialReferenceTolerance",[e])}class o extends Error{constructor(){super("Illegal Argument Exception")}}export{W as buffer,ie as changeDefaultSpatialReferenceTolerance,ce as clearDefaultSpatialReferenceTolerance,O as clip,D as contains,I as convexHull,N as crosses,J as cut,_ as densify,j as difference,b as disjoint,L as distance,T as equals,A as extendedSpatialReferenceInfo,X as flipHorizontal,Y as flipVertical,Z as generalize,ne as geodesicArea,F as geodesicBuffer,$ as geodesicDensify,ae as geodesicLength,q as intersect,re as intersectLinesToPoints,V as intersects,P as isSimple,K as nearestCoordinate,M as nearestVertex,Q as nearestVertices,C as offset,z as overlaps,ee as planarArea,te as planarLength,H as relate,U as rotate,G as simplify,k as symmetricDifference,v as touches,B as union,E as within};
